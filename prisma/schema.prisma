generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User role enum
enum UserRole {
  USER
  ADMIN
  ORACLE
}

// Notification type enum
enum NotificationType {
  WIN
  LOSS
  ROUND_START
  BONUS_AVAILABLE
  ANNOUNCEMENT
}

// User model for wallet-based authentication
model User {
  id              String            @id @default(uuid())
  walletAddress   String            @unique
  publicKey       String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  lastLoginAt     DateTime?
  
  // Game stats
  wins            Int               @default(0)
  streak          Int               @default(0)
  virtualBalance  Float             @default(1000)

  // Role
  role            UserRole          @default(USER)

  // Notification preferences
  notificationPreferences Json?     @default("{\"win\": true, \"loss\": true, \"roundStart\": false, \"bonus\": true, \"announcement\": true}")

  // Relations
  authChallenges  AuthChallenge[]
  predictions     Prediction[]
  stats           UserStats?
  notifications   Notification[]

  @@index([walletAddress])
}

// Auth challenge model for replay protection
model AuthChallenge {
  id            String    @id @default(uuid())
  userId        String?
  user          User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge     String    @unique
  walletAddress String
  createdAt     DateTime  @default(now())
  expiresAt     DateTime
  usedAt        DateTime?
  isUsed        Boolean   @default(false)

  @@index([challenge])
  @@index([walletAddress])
  @@index([expiresAt])
}

// Prediction model for user price predictions
model Prediction {
  id              String   @id @default(uuid())
  userId          String
  roundId         String
  mode            Int      // 0 = Up/Down, 1 = Legends (exact price)
  choice          String?  // "up" or "down" for mode 0; null for mode 1
  guessPrice      Decimal? @db.Decimal(10, 4)  // only for mode 1 (e.g. 0.2297)
  amount          Decimal  @db.Decimal(18, 8)   // virtual XLM staked
  won             Boolean? // null = not resolved, true = winner, false = loser
  payout          Decimal? @db.Decimal(18, 8)   // payout amount received
  createdAt       DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id])
  round           Round    @relation(fields: [roundId], references: [id])

  @@unique([roundId, userId])
  @@index([userId])
  @@index([roundId])
}

// Round model for prediction rounds
model Round {
  id          String   @id @default(uuid())
  mode        Int      // 0 = Up/Down, 1 = Legends
  startPrice  Decimal? @db.Decimal(10, 4)
  endPrice    Decimal? @db.Decimal(10, 4)
  startTime   DateTime
  endTime     DateTime
  status      String   // "ACTIVE", "LOCKED", "RESOLVED"
  resolvedAt  DateTime? // timestamp when round was resolved
  sorobanRoundId String?
  poolUp      Decimal  @default(0) @db.Decimal(18, 8)  // Total XLM staked on UP
  poolDown    Decimal  @default(0) @db.Decimal(18, 8)  // Total XLM staked on DOWN
  priceRanges Json?    // Price ranges for LEGENDS mode
  createdAt   DateTime @default(now())

  predictions Prediction[]

  @@index([status])
}

// UserStats model for leaderboard tracking
model UserStats {
  id                String   @id @default(uuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Overall stats
  totalPredictions  Int      @default(0)
  correctPredictions Int     @default(0)
  totalEarnings     Decimal  @default(0) @db.Decimal(18, 8)
  
  // Mode-specific stats
  upDownWins        Int      @default(0)
  upDownLosses      Int      @default(0)
  upDownEarnings    Decimal  @default(0) @db.Decimal(18, 8)
  
  legendsWins       Int      @default(0)
  legendsLosses     Int      @default(0)
  legendsEarnings   Decimal  @default(0) @db.Decimal(18, 8)
  
  // Metadata
  updatedAt         DateTime @updatedAt
  
  @@index([totalEarnings])
}

// Game mode enum
enum GameMode {
  UP_DOWN    // Mode 0: Binary Up/Down predictions
  LEGENDS    // Mode 1: Price range predictions
}

// Round status enum
enum RoundStatus {
  PENDING    // Created but not started
  ACTIVE     // Accepting predictions
  LOCKED     // No more predictions, awaiting resolution
  RESOLVED   // Completed with results
  CANCELLED  // Admin cancelled
}

// Prediction side for Up/Down mode
enum PredictionSide {
  UP
  DOWN
}

// Notification model for user notifications
model Notification {
  id              String           @id @default(uuid())
  userId          String
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type            NotificationType
  title           String
  message         String
  data            Json?            // Optional payload (e.g., roundId, amount, etc.)
  
  isRead          Boolean          @default(false)
  createdAt       DateTime         @default(now())
  
  @@index([userId])
  @@index([createdAt])
  @@index([isRead])
}
